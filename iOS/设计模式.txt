设计模式：
1、工厂方法：
	工厂方法模式：提供一个方法，用于创建实例
	抽象工厂模式：将创建实例的过程封装成一个类，并返回接口，而不是具体对象，被称为其他工厂的工厂
2、单件模式：
	提供一个类方法，返回一个独一无二的实例，内部需要加锁防止多线程，iOS通过dispatch-once实现，双重检测锁：因为只有第一次实例化的时候多线程才会出错，因此如果因为这样就锁定整个方法，后面再创建的时候都会锁定，不划算。双重检测锁可避免，只会锁定一次。
3、命令模式：
	将请求或者动作封装到命令类，将调用者和被调用者用命令类解藕，可支持撤销操作。	
4、适配器模式：
	将原先的类，封装到另一个类，用于模拟另一个类。在版本迭代时，很适合新旧类的兼容
5、外观模式：
	将一群类封装到一个类并提供统一的接口。方便使用
6、模版方法：
	将一组算法抽象到一个类，该类提供算法模版，由子类实现模版中的方法
7、迭代器方法：
	一共一个迭代器用于对数组或list对访问，不需要暴露内部的数据结构
8、组合模式：
	将对象和对象组合通过树形结构来表示包含关系：类似Dic中的Dic，Array中的Array。
9、状态模式：
	直接对状态进行编程，当状态增加时，所有状态的切换都需要重新添加代码。不方便。可以把状态封装成一个类，并在每个状态类内部实现状态切换代码，当状态类增加时，不用改动原有的代码。（可以在headview下拉借鉴）
10、代理模式：
	为一个对象提供一个替身：NSProxy，实际调用的是target对象而不是nsproxy。
11、策略模式：
	将算法的变化抽象出来封装到类中，算法间可自由对换
12、观察者模式：
	观察者与被观察者为多对一关系，被观察者状态变化时，会通知观察者：KVO
13、装饰者模式：
	在原有的类外面封装一层类，两个类拥有同样的接口，可以迭代调用。有利于功能的扩展。
14、建造者模式（Builder Pattern）：
	使用多个简单的对象一步一步构建成一个复杂的对象
15、原型模式（Prototype Pattern）：
	是用于创建重复的对象，同时又能保证性能。在类似读取数据库等消耗性能的创建对象时，它提供了一种创建对象的最佳方式
16、桥接模式：
	类似iOS的delegate，单项持有关系。作为桥接的接口，使得实体类的功能独立于接口实现类
17、过滤器模式：
	提供一组过滤器接口来对一组数据对象进行筛选。
18、享元模式（Flyweight Pattern）：
	主要用于减少创建对象的数量，以减少内存占用和提高性能。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象	
19、责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。
20、解释器模式（Interpreter Pattern）“
	提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
21、备忘录模式（Memento Pattern）：
	保存一个对象的某个状态，以便在适当的时候恢复对象
22、空对象模式（Null Object Pattern）：
	一个空对象取代 NULL 对象实例的检查
23、访问者模式（Visitor Pattern）：
	使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变
24、数据访问对象模式：DAO
	封装数据对象的增删改查
25、业务代表模式（Business Delegate Pattern）：
	用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能
26、组合实体模式（Composite Entity Pattern）
	将多个类组合到一个类的一起操作
27、前端控制器模式（Front Controller Pattern）：
	是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。
28、拦截过滤器模式（Intercepting Filter Pattern）
	用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上


OO原则：封装变化、多组合少继承、针对接口编程不针对实现、松耦合、对扩展开放对修改关闭、依赖抽象不依赖具体类、朋友越少越好、代理模式、一个类一个责任

设计模式的六大原则
1、开闭原则（Open Close Principle）
对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
任何基类可以出现的地方，子类一定可以出现。。
3、依赖倒转原则（Dependence Inversion Principle）
针对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
降低类之间的耦合度。
5、迪米特法则，又称最少知道原则（Demeter Principle）
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
尽量使用合成/聚合的方式，而不是使用继承。


面试题：
https://www.cnblogs.com/wozixiaoyao/p/5658820.html
http://www.cocoachina.com/ios/20170829/20408.html
https://www.cnblogs.com/study-makes-me-happy/p/7839052.html